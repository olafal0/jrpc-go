// Code generated by jrpc. DO NOT EDIT.

// Package {{.PkgName}} is an auto-generated package providing HTTP handler
// functions that wrap handlers in the {{.SpecPkgPath}} package.
package {{.PkgName}}

import (
	"encoding/json"
	"io/ioutil"
	"net/http"
  "{{.SpecPkgPath}}"
)

{{range $method := .Methods}}
type {{$method.Name}}Input struct {
  {{range $param := $method.Params}}
	{{ export $param.Name}} {{$param.Type}} `json:"{{$param.Name}}"`
  {{end}}
}

func {{$method.Name}}Handler(recv *{{$.SpecPkgName}}.{{$.Receiver}}) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		if r.Method != "POST" {
			http.Error(w, "Only POST requests supported", http.StatusMethodNotAllowed)
			return
		}

		bodyBytes, err := ioutil.ReadAll(r.Body)
		if err != nil {
			http.Error(w, err.Error(), http.StatusBadRequest)
			return
		}

		input := {{$method.Name}}Input{}
		err = json.Unmarshal(bodyBytes, &input)
		if err != nil {
			http.Error(w, err.Error(), http.StatusBadRequest)
			return
		}

		res, err := recv.{{$method.ExportedName}}(
			{{- if $method.TakesCtx}}
			r.Context(),
			{{- end}}
			{{range $param := $method.Params -}}
			input.{{ export $param.Name}},
			{{end}}
		)
		if err != nil {
			http.Error(w, err.Error(), http.StatusInternalServerError)
			return
		}

		resBytes, err := json.Marshal(res)
		if err != nil {
			http.Error(w, err.Error(), http.StatusInternalServerError)
			return
		}
		w.Header().Set("Content-Type", "application/json")
		w.Write(resBytes)
	}
}
{{end}}

func Handler(recv *{{$.SpecPkgName}}.{{.Receiver}}) http.Handler {
	mux := http.NewServeMux()
  {{- range $method := .Methods}}
	mux.HandleFunc("/{{$method.ExportedName}}", {{$method.Name}}Handler(recv))
  {{- end}}
	return mux
}
